<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twin-2048: Human vs AI</title>
  <style>
    body {
      font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background-color: #faf8ef;
      color: #776e65;
    }
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    #turnStatus {
      font-size: 24px;
      font-weight: bold;
      padding: 10px 30px;
      border-radius: 6px;
      background-color: #bbada0;
      color: white;
      margin-bottom: 15px;
      transition: all 0.3s ease;
      min-width: 200px;
    }
    .turn-player { background-color: #8f7a66 !important; }
    .turn-ai { background-color: #f65e3b !important; }

    .instructions {
      font-size: 14px;
      margin-bottom: 10px;
      color: #776e65;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }
    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .game-title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .gameBoard {
      position: relative;
      background-color: #bbada0;
      border-radius: 6px;
      padding: 3px;
    }
    .gameCell {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      border-radius: 3px;
      transition: none;
      z-index: 10;
    }
    .controls {
      margin-top: 30px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #8f7a66;
      color: #f9f6f2;
    }
    button:hover { background-color: #9f8a76; }

    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(238, 228, 218, 0.96);
      padding: 40px;
      border-radius: 10px;
      text-align: center;
      z-index: 2000;
      box-shadow: 0 0 30px rgba(0,0,0,0.3);
    }
    .game-over h2 { font-size: 36px; margin-bottom: 10px; }
    .hidden { display: none; }
  </style>
</head>
<body>

    <div class="header">
      <div id="turnStatus" class="turn-player">YOUR TURN</div>
      <div id="bonusMsg" style="font-size:18px; font-weight:bold; color:#f65e3b; min-height:28px; margin-top:4px;"></div>
      <div class="instructions">
        Move both boards. <b>If you make either board get stuck, you lose!</b><br>
        <span style="font-size:12px;">Make a tile of 32+ to earn a bonus turn! Bonus turns can chain ‚Äî but your board can trap you too.</span><BR>
        <span>based on 2048 (gabrielecirulli.github.io/2048)</span>
      </div>
    </div>

  <div class="container">
    <div class="game-wrapper">
      <div class="game-title">Board 1</div>
      <div id="gameBoard1" class="gameBoard"></div>
    </div>
    <div class="game-wrapper">
      <div class="game-title">Board 2</div>
      <div id="gameBoard2" class="gameBoard"></div>
    </div>
  </div>

  <div class="controls">
    <button id="resetButton">Reset Game</button>
  </div>

  <div id="gameOver" class="game-over hidden">
    <h2 id="winLossMessage">GAME OVER</h2>
    <p id="reasonMessage" style="margin-bottom: 20px;"></p>
    <button id="restartButton">Try Again</button>
  </div>

  <script>
    let global = { keys: [] };
    let isPlayerTurn = true;
    let isProcessing = false;

    function calcSettings() {
      const margin = 3;
      const boardSize = Math.floor(Math.min(window.innerWidth, window.innerHeight / 2.6) * 0.88);
      const cellSize = Math.floor((boardSize - margin * 5) / 4);
      return {
        CELL_WIDTH: cellSize,
        CELL_HEIGHT: cellSize,
        CELL_MARGIN: margin,
        ANIMATION_SWELLING: Math.max(4, Math.floor(cellSize * 0.12)),
        ANIMATION_GEN_TIME: 100,
        FONT_SIZE: Math.floor(cellSize * 0.38),
        BOARD_SIZE: boardSize
      };
    }
    let Settings = calcSettings();

    class State {
      constructor() {
        this.board = Array(16).fill(0);
        this.merge = Array(16).fill(false);
        this.moveCells = [];
        this.move = -1;
      }
      calcNextState(dir) {
        let nextState = new State();
        nextState.board = [...this.board];
        if (dir == 0) nextState._moveUp();
        else if (dir == 1) { nextState._rotate(3); nextState._moveUp(); nextState._rotate(1); }
        else if (dir == 2) { nextState._rotate(2); nextState._moveUp(); nextState._rotate(2); }
        else { nextState._rotate(1); nextState._moveUp(); nextState._rotate(3); }
        if (nextState.moveCells.length > 0) this.move = dir;
        return nextState;
      }
      isDie() {
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            if (this.board[i * 4 + j] === 0) return false;
            const dx = [1, 0], dy = [0, 1];
            for (let k = 0; k < 2; ++k) {
              let ni = i + dy[k], nj = j + dx[k];
              if (ni < 4 && nj < 4 && this.board[i * 4 + j] === this.board[ni * 4 + nj]) return false;
            }
          }
        }
        return true;
      }
      getEmptyCells() {
        return this.board.map((v, i) => v === 0 ? i : null).filter(v => v !== null);
      }
      rewriteCells(y, x, value) { this.board[y * 4 + x] = value; }
      _rotate(rot) {
        for (let i = 0; i < rot; ++i) {
          let nb = [], nm = [];
          for (let j = 0; j < 16; ++j) {
            let y = Math.floor(j/4), x = j%4;
            nb[x*4+(3-y)] = this.board[j];
            nm[x*4+(3-y)] = this.merge[j];
          }
          this.board = nb; this.merge = nm;
          this.moveCells = this.moveCells.map(c => ({fx: 3-c.fy, fy: c.fx, tx: 3-c.ty, ty: c.tx}));
        }
      }
      _moveUp() {
        this.merge.fill(false);
        for (let y = 1; y < 4; y++) {
          for (let x = 0; x < 4; ++x) {
            if (this.board[y*4+x] === 0) continue;
            let cy = y;
            while (cy >= 1) {
              const num = this.board[(cy-1)*4+x];
              if (num === 0) {
                this.board[(cy-1)*4+x] = this.board[cy*4+x];
                this.board[cy*4+x] = 0; cy--;
              } else if (num === this.board[cy*4+x] && !this.merge[cy*4+x] && !this.merge[(cy-1)*4+x]) {
                this.board[(cy-1)*4+x] = 2*num;
                this.board[cy*4+x] = 0;
                this.merge[(cy-1)*4+x] = true; cy--;
              } else break;
            }
            if (cy != y) this.moveCells.push({fx: x, fy: y, tx: x, ty: cy});
          }
        }
      }
    }

    class Game {
      constructor(screenId) {
        this.screen = document.getElementById(screenId);
        this.screen.style.width = Settings.BOARD_SIZE + "px";
        this.screen.style.height = Settings.BOARD_SIZE + "px";
        this.animation = new Animation(this.screen);
        this.state = new State();
        for (let i = 0; i < 2; i++) this.spawnTile();
      }
      spawnTile() {
        const empty = this.state.getEmptyCells();
        if (empty.length > 0) {
          const idx = empty[Math.floor(Math.random() * empty.length)];
          const num = Math.random() < 0.9 ? 2 : 4;
          this.state.rewriteCells(Math.floor(idx/4), idx%4, num);
          this.animation.generate(this.screen, Math.floor(idx/4), idx%4, num, 1);
        }
      }
      move(dir) {
        if (!this.animation.finish) return {moved: false, maxMerge: 0};
        let nextState = this.state.calcNextState(dir);
        if (nextState.moveCells.length > 0) {
          // „Éû„Éº„Ç∏„Åï„Çå„Åü„Çª„É´„ÅÆÊúÄÂ§ßÂÄ§„ÇíÂèñÂæó
          let maxMerge = 0;
          for (let i = 0; i < 16; i++) {
            if (nextState.merge[i]) maxMerge = Math.max(maxMerge, nextState.board[i]);
          }
          const empty = nextState.getEmptyCells();
          const num = Math.random() < 0.9 ? 2 : 4;
          const idx = empty[Math.floor(Math.random() * empty.length)];
          nextState.rewriteCells(Math.floor(idx/4), idx%4, num);
          this.animation.update(nextState, Math.floor(idx/4), idx%4, num);
          this.state = nextState;
          return {moved: true, maxMerge};
        }
        return {moved: false, maxMerge: 0};
      }
    }

    class Animation {
      constructor(screen) {
        this.cells = []; this.pos = new Map(); this.itr = 0; this.screen = screen; this.finish = true;
        for (let i = 0; i < 16; i++) {
          const cell = new Cell(0, screen); cell.setPos(Math.floor(i/4), i%4);
        }
      }
      update(state, addY, addX, addNum) {
        this.finish = false;
        let start = null;
        let map = new Map();
        for (const move of state.moveCells) {
          let index = -1;
          this.pos.forEach((v, k) => { if (v.x === move.fx && v.y === move.fy) index = k; });
          if (index !== -1) map.set(index, move);
        }
        map.forEach((v, k) => this.pos.set(k, {x: v.tx, y: v.ty}));

        const procMove = (timestamp) => {
          if (!start) start = timestamp;
          let progress = Math.min((timestamp - start) / Settings.ANIMATION_GEN_TIME, 1);
          map.forEach((v, k) => this.cells[k].translate(v.fx, v.fy, v.tx, v.ty, progress));
          if (progress < 1) requestAnimationFrame(procMove);
        };
        requestAnimationFrame(procMove);

        setTimeout(() => {
          let deleteIndex = [], animationIndex = [];
          for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
              if (state.merge[y*4+x]) {
                let ids = [];
                this.pos.forEach((v, k) => { if (v.x === x && v.y === y) ids.push(k); });
                deleteIndex.push(ids[0]); animationIndex.push(ids[1]);
              }
            }
          }
          const addIndex = this.itr++;
          this.pos.set(addIndex, {x: addX, y: addY});
          let startGen = null;
          const procGen = () => {
            if (!startGen) { startGen = new Date(); this.cells[addIndex] = new Cell(addNum, this.screen); }
            let progress = Math.min((new Date() - startGen) / Settings.ANIMATION_GEN_TIME, 1);
            animationIndex.forEach(idx => {
              let p = this.pos.get(idx);
              this.cells[idx].changeAttrib(state.board[p.y*4+p.x]);
              this.cells[idx].appear(p.y, p.x, progress, 2);
            });
            this.cells[addIndex].appear(addY, addX, progress, 1);
            if (progress < 1) requestAnimationFrame(procGen);
            else {
              this.finish = true;
              deleteIndex.forEach(idx => { this.screen.removeChild(this.cells[idx].elem); this.cells[idx] = null; this.pos.delete(idx); });
            }
          };
          requestAnimationFrame(procGen);
        }, Settings.ANIMATION_GEN_TIME * 1.1);
      }
      generate(screen, y, x, num, type=0) {
        let index = this.itr++;
        this.cells[index] = new Cell(num, screen);
        this.pos.set(index, {x: x, y: y});
        let start = null;
        const update = (timestamp) => {
          if (!start) start = timestamp;
          let progress = Math.min((timestamp - start) / Settings.ANIMATION_GEN_TIME, 1);
          this.cells[index].appear(y, x, progress, type);
          if (progress < 1) requestAnimationFrame(update);
        };
        requestAnimationFrame(update);
      }
    }

    class Cell {
      constructor(num, screen) { this.elem = document.createElement("div"); this.elem.classList.add("gameCell"); screen.appendChild(this.elem); this.changeAttrib(num); }
      translate(fx, fy, tx, ty, p) {
        this.elem.style.left = `${(fx + (tx - fx) * p) * (Settings.CELL_WIDTH + Settings.CELL_MARGIN) + Settings.CELL_MARGIN}px`;
        this.elem.style.top = `${(fy + (ty - fy) * p) * (Settings.CELL_HEIGHT + Settings.CELL_MARGIN) + Settings.CELL_MARGIN}px`;
      }
      setPos(y, x) { this.appear(y, x, 0); }
      appear(y, x, p, type=0) {
        let h = Settings.CELL_HEIGHT, w = Settings.CELL_WIDTH, f = Settings.FONT_SIZE;
        if (type === 1) { h *= p; w *= p; f *= p; }
        else if (type === 2) { 
          let swell = Settings.ANIMATION_SWELLING * Math.sin(Math.PI * p);
          h += swell; w += swell; f *= (h / Settings.CELL_HEIGHT);
        }
        this.elem.style.width = `${w}px`; this.elem.style.height = `${h}px`;
        this.elem.style.left = `${x * (Settings.CELL_WIDTH + Settings.CELL_MARGIN) + Settings.CELL_MARGIN + (Settings.CELL_WIDTH - w)/2}px`;
        this.elem.style.top = `${y * (Settings.CELL_HEIGHT + Settings.CELL_MARGIN) + Settings.CELL_MARGIN + (Settings.CELL_HEIGHT - h)/2}px`;
        this.elem.style.fontSize = `${f}px`; this.elem.style.lineHeight = `${h}px`;
      }
      changeAttrib(num) {
        this.elem.textContent = num > 0 ? num : "";
        const colors = { 0: "#ccc", 2: "#eee", 4: "#eec", 8: "#f93", 16: "#c66", 32: "#c33", 64: "#c11", 128: "#fc6", 256: "#fc5", 512: "#fc3", 1024: "#fc1", 2048: "#fc0" };
        this.elem.style.backgroundColor = colors[num] || "#222";
        this.elem.style.color = num <= 4 ? "#776e65" : "#fff";
      }
    }

    class GameAI {
      constructor(forceType = null) {
        // forceType„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„Åù„Çå„Çí‰ΩøÁî®„ÄÅ„Å™„Åë„Çå„Å∞Á¢∫Áéá„ÅßÊ±∫ÂÆö
        const type = forceType || (() => {
          const r = Math.random();
          if (r < 0.75) return 'normal';
          if (r < 0.95) return 'strong';
          return 'hidden';
        })();
        this.type = type;
        this.baseMax = type === 'strong' ? 12 : 6; // normal/hidden„Å®„ÇÇ„Å´ÊôÆÊÆµ„ÅØmax=6
        console.log(`CPU type: ${this.type}`); // „Éá„Éê„ÉÉ„Ç∞Áî®Ôºà„Éó„É¨„Ç§„É§„Éº„Å´„ÅØÈùûË°®Á§∫Ôºâ
      }
      getDepth(emptyTotal) {
        if (this.type === 'hidden' && emptyTotal <= 12) return 30;
        return this.baseMax;
      }
      nextMove(state, emptyTotal) {
        const canMove = [0,1,2,3].filter(d => state.calcNextState(d).moveCells.length > 0);
        if (canMove.length === 0) return 0;
        const max = this.getDepth(emptyTotal);
        let scores = canMove.map(dir => {
          let score = 0;
          for(let i=0; i<500; i++) score += this._sim(state.calcNextState(dir), 1, max);
          return {dir, score};
        });
        return scores.sort((a,b) => b.score - a.score)[0].dir;
      }
      _sim(state, d, max) {
        if (d >= max) return 1;
        const empty = state.getEmptyCells();
        if (empty.length > 0) state.board[empty[Math.floor(Math.random()*empty.length)]] = Math.random()<0.9?2:4;
        if (state.isDie()) return 0;
        return this._sim(state.calcNextState(Math.floor(Math.random()*4)), d+1, max);
      }
    }

    let game1, game2, gameAI;
    let resetCount = 0;

    function init() {
      document.getElementById("gameBoard1").innerHTML = "";
      document.getElementById("gameBoard2").innerHTML = "";
      game1 = new Game("gameBoard1");
      game2 = new Game("gameBoard2");
      resetCount++;
      if (resetCount >= 10) {
        gameAI = new GameAI('hidden');
        resetCount = 0;
      } else {
        gameAI = new GameAI();
      }
      isPlayerTurn = true; isProcessing = false;
      updateUI();
      document.getElementById("gameOver").classList.add("hidden");
      document.getElementById("bonusMsg").textContent = "";
    }

    function updateUI() {
      const el = document.getElementById("turnStatus");
      el.textContent = isPlayerTurn ? "YOUR TURN" : "AI'S TURN";
      el.className = isPlayerTurn ? "turn-player" : "turn-ai";
    }

    async function executeStep(dir) {
      if (isProcessing) return;
      isProcessing = true;

      const r1 = game1.move(dir);
      const r2 = game2.move(dir);

      if (!r1.moved && !r2.moved) { isProcessing = false; return; }

      await new Promise(r => setTimeout(r, Settings.ANIMATION_GEN_TIME * 2.5));

      if (game1.state.isDie() || game2.state.isDie()) {
        document.getElementById("winLossMessage").textContent = isPlayerTurn ? "AI WINS!" : "YOU WIN!";
        document.getElementById("reasonMessage").textContent = isPlayerTurn ? "You triggered a Game Over." : "The AI triggered a Game Over.";
        document.getElementById("gameOver").classList.remove("hidden");
        isProcessing = false;  // ËøΩÂä†  20260218      
        return;
      }

      const bonusEl = document.getElementById("bonusMsg");
      const maxMerge = Math.max(r1.maxMerge, r2.maxMerge);
      const earnedBonus = maxMerge >= 32;

      if (earnedBonus) {
        bonusEl.textContent = isPlayerTurn ? `üéâ BONUS TURN! (${maxMerge} made)` : `‚ö° AI BONUS TURN! (${maxMerge} made)`;
        // „Çø„Éº„É≥‰∫§‰ª£„Åó„Å™„ÅÑÔºàÈÄ£Á∂öÊìç‰ΩúÔºâ
      } else {
        bonusEl.textContent = "";
        isPlayerTurn = !isPlayerTurn;
      }
      updateUI();
      isProcessing = false;

      if (!isPlayerTurn) {
        const emptyTotal = game1.state.getEmptyCells().length + game2.state.getEmptyCells().length;
        setTimeout(() => {
          //20260218Áõ§Èù¢„ÅÆÁ©∫„Åç„ÅåÂ∞ë„Å™„ÅÑÊñπ„ÇíÂÑ™ÂÖà
          //const move = gameAI.nextMove(Math.random() > 0.5 ? game1.state : game2.state, emptyTotal);
          const dangerState = game1.state.getEmptyCells().length <= game2.state.getEmptyCells().length
          ? game1.state
          : game2.state;
          const move = gameAI.nextMove(dangerState, emptyTotal);
executeStep(move);
        }, earnedBonus ? 900 : 600);
      }
    }

    document.addEventListener("keydown", (e) => {
      if (!isPlayerTurn || isProcessing) return;
      const dirs = { 38:0, 39:1, 40:2, 37:3 };
      if (dirs[e.keyCode] !== undefined) executeStep(dirs[e.keyCode]);
    });

    document.getElementById("resetButton").onclick = init;
    document.getElementById("restartButton").onclick = init;

    // Touch/Swipe support
    let touchStartX = 0;
    let touchStartY = 0;
    document.addEventListener("touchstart", (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener("touchend", (e) => {
      if (!isPlayerTurn || isProcessing) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
      let dir = -1;
      if (Math.abs(dx) >= Math.abs(dy)) {
        dir = dx > 0 ? 1 : 3; // right : left
      } else {
        dir = dy > 0 ? 2 : 0; // down : up
      }
      executeStep(dir);
    }, { passive: true });

    init();
  </script>
</body>
</html>