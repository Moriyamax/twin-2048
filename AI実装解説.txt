AI実装解説（Twin-2048）

1.概要
このゲームのAIは Monte Carlo Simulation（モンテカルロ法）を用いて次の手を決定します。

2.特徴
・盤面評価関数ベースではない
・ランダムプレイアウトによる「生存率」評価
・深さ（lookahead depth）を動的制御
・複数AIモード（Normal / Strong / Hidden）

3.モンテカルロ法の選択理由
このゲーム向けアルゴリズムを考えるにあたって、次の条件があります。
・新規タイル生成が確率的
・局所評価が必ずしも正解にならない
・詰まないことが目標

Twin-2048では
・2盤面同時操作
・どちらか詰みで敗北
・ボーナスターン連鎖
という構造が非線形になるルールがあるので、
"理論的最善手"より"統計的に死ににくい手"を選ぶ戦略が有利になります。
このため、実装が容易で堅牢なMonte Carloが最も要件に適合しました。


4.基本アルゴリズム
(1)移動可能方向の列挙
const canMove = [0,1,2,3]
.filter(d => state.calcNextState(d).moveCells.length > 0);

・実際に変化が起きる手のみ対象

(2)各方向をモンテカルロ評価
for(let i=0; i<500; i++)
score += this._sim(nextState, depth=1, maxDepth);

・500回ランダム試行
・生存できたら +1
・詰んだら 0

(3)最もスコアの高い方向を選択
return scores.sort((a,b) => b.score - a.score)[0].dir;

・未来で詰みにくい方向を選択。


5.このAIの長所/短所
長所:
・実装がシンプル（評価関数チューニング不要）
・双盤面制約に強い（局所ヒューリスティック依存しない）
・難易度調整が簡単（rollout回数・深さ・確率などパラメータを調整するたけ）
・雑な設計でもそこそこ動作する

短所:
最善手保証がない（統計近似）
計算量依存（深さ30は重いので終盤のみ使用）
盤面構造理解がない
